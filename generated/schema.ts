// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class ExecutionParams extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExecutionParams entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExecutionParams must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExecutionParams", id.toString(), this);
    }
  }

  static load(id: string): ExecutionParams | null {
    return changetype<ExecutionParams | null>(store.get("ExecutionParams", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get collateralToken(): Bytes {
    let value = this.get("collateralToken");
    return value!.toBytes();
  }

  set collateralToken(value: Bytes) {
    this.set("collateralToken", Value.fromBytes(value));
  }

  get debtToken(): Bytes {
    let value = this.get("debtToken");
    return value!.toBytes();
  }

  set debtToken(value: Bytes) {
    this.set("debtToken", Value.fromBytes(value));
  }

  get collateralAmount(): BigInt {
    let value = this.get("collateralAmount");
    return value!.toBigInt();
  }

  set collateralAmount(value: BigInt) {
    this.set("collateralAmount", Value.fromBigInt(value));
  }

  get debtAmount(): BigInt {
    let value = this.get("debtAmount");
    return value!.toBigInt();
  }

  set debtAmount(value: BigInt) {
    this.set("debtAmount", Value.fromBigInt(value));
  }

  get collateralAmountWithTotalFee(): BigInt {
    let value = this.get("collateralAmountWithTotalFee");
    return value!.toBigInt();
  }

  set collateralAmountWithTotalFee(value: BigInt) {
    this.set("collateralAmountWithTotalFee", Value.fromBigInt(value));
  }

  get swap(): string {
    let value = this.get("swap");
    return value!.toString();
  }

  set swap(value: string) {
    this.set("swap", Value.fromString(value));
  }

  get route(): BigInt {
    let value = this.get("route");
    return value!.toBigInt();
  }

  set route(value: BigInt) {
    this.set("route", Value.fromBigInt(value));
  }

  get rateMode(): BigInt {
    let value = this.get("rateMode");
    return value!.toBigInt();
  }

  set rateMode(value: BigInt) {
    this.set("rateMode", Value.fromBigInt(value));
  }
}

export class Swap extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Swap entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Swap must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Swap", id.toString(), this);
    }
  }

  static load(id: string): Swap | null {
    return changetype<Swap | null>(store.get("Swap", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get buyToken(): Bytes {
    let value = this.get("buyToken");
    return value!.toBytes();
  }

  set buyToken(value: Bytes) {
    this.set("buyToken", Value.fromBytes(value));
  }

  get sellToken(): Bytes {
    let value = this.get("sellToken");
    return value!.toBytes();
  }

  set sellToken(value: Bytes) {
    this.set("sellToken", Value.fromBytes(value));
  }

  get sellAmt(): BigInt {
    let value = this.get("sellAmt");
    return value!.toBigInt();
  }

  set sellAmt(value: BigInt) {
    this.set("sellAmt", Value.fromBigInt(value));
  }

  get unitAmt(): BigInt {
    let value = this.get("unitAmt");
    return value!.toBigInt();
  }

  set unitAmt(value: BigInt) {
    this.set("unitAmt", Value.fromBigInt(value));
  }

  get callData(): Bytes {
    let value = this.get("callData");
    return value!.toBytes();
  }

  set callData(value: Bytes) {
    this.set("callData", Value.fromBytes(value));
  }
}

export class Spell extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Spell entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Spell must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Spell", id.toString(), this);
    }
  }

  static load(id: string): Spell | null {
    return changetype<Spell | null>(store.get("Spell", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _targets(): Array<string> {
    let value = this.get("_targets");
    return value!.toStringArray();
  }

  set _targets(value: Array<string>) {
    this.set("_targets", Value.fromStringArray(value));
  }

  get _datas(): Array<Bytes> {
    let value = this.get("_datas");
    return value!.toBytesArray();
  }

  set _datas(value: Array<Bytes>) {
    this.set("_datas", Value.fromBytesArray(value));
  }
}

export class TransactionData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TransactionData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TransactionData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TransactionData", id.toString(), this);
    }
  }

  static load(id: string): TransactionData | null {
    return changetype<TransactionData | null>(store.get("TransactionData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get timeStamp(): BigInt {
    let value = this.get("timeStamp");
    return value!.toBigInt();
  }

  set timeStamp(value: BigInt) {
    this.set("timeStamp", Value.fromBigInt(value));
  }

  get logIndex(): BigInt {
    let value = this.get("logIndex");
    return value!.toBigInt();
  }

  set logIndex(value: BigInt) {
    this.set("logIndex", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get transactionLogIndex(): BigInt {
    let value = this.get("transactionLogIndex");
    return value!.toBigInt();
  }

  set transactionLogIndex(value: BigInt) {
    this.set("transactionLogIndex", Value.fromBigInt(value));
  }
}

export class Account extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Account entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Account must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Account", id.toString(), this);
    }
  }

  static load(id: string): Account | null {
    return changetype<Account | null>(store.get("Account", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get submitAutomation(): Array<string> {
    let value = this.get("submitAutomation");
    return value!.toStringArray();
  }

  set submitAutomation(value: Array<string>) {
    this.set("submitAutomation", Value.fromStringArray(value));
  }

  get executeAutomation(): Array<string> {
    let value = this.get("executeAutomation");
    return value!.toStringArray();
  }

  set executeAutomation(value: Array<string>) {
    this.set("executeAutomation", Value.fromStringArray(value));
  }

  get cancelData(): Array<string> {
    let value = this.get("cancelData");
    return value!.toStringArray();
  }

  set cancelData(value: Array<string>) {
    this.set("cancelData", Value.fromStringArray(value));
  }

  get systemCancelData(): Array<string> {
    let value = this.get("systemCancelData");
    return value!.toStringArray();
  }

  set systemCancelData(value: Array<string>) {
    this.set("systemCancelData", Value.fromStringArray(value));
  }

  get failedExecutionData(): Array<string> {
    let value = this.get("failedExecutionData");
    return value!.toStringArray();
  }

  set failedExecutionData(value: Array<string>) {
    this.set("failedExecutionData", Value.fromStringArray(value));
  }
}

export class SubmitData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SubmitData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SubmitData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SubmitData", id.toString(), this);
    }
  }

  static load(id: string): SubmitData | null {
    return changetype<SubmitData | null>(store.get("SubmitData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get safeHF(): BigInt {
    let value = this.get("safeHF");
    return value!.toBigInt();
  }

  set safeHF(value: BigInt) {
    this.set("safeHF", Value.fromBigInt(value));
  }

  get thresholdHF(): BigInt {
    let value = this.get("thresholdHF");
    return value!.toBigInt();
  }

  set thresholdHF(value: BigInt) {
    this.set("thresholdHF", Value.fromBigInt(value));
  }

  get currentHf(): BigInt {
    let value = this.get("currentHf");
    return value!.toBigInt();
  }

  set currentHf(value: BigInt) {
    this.set("currentHf", Value.fromBigInt(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}

export class ExecuteData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExecuteData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExecuteData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExecuteData", id.toString(), this);
    }
  }

  static load(id: string): ExecuteData | null {
    return changetype<ExecuteData | null>(store.get("ExecuteData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get finalHf(): BigInt {
    let value = this.get("finalHf");
    return value!.toBigInt();
  }

  set finalHf(value: BigInt) {
    this.set("finalHf", Value.fromBigInt(value));
  }

  get initialHf(): BigInt {
    let value = this.get("initialHf");
    return value!.toBigInt();
  }

  set initialHf(value: BigInt) {
    this.set("initialHf", Value.fromBigInt(value));
  }

  get automationFee(): i32 {
    let value = this.get("automationFee");
    return value!.toI32();
  }

  set automationFee(value: i32) {
    this.set("automationFee", Value.fromI32(value));
  }

  get params(): string {
    let value = this.get("params");
    return value!.toString();
  }

  set params(value: string) {
    this.set("params", Value.fromString(value));
  }

  get isSafe(): boolean {
    let value = this.get("isSafe");
    return value!.toBoolean();
  }

  set isSafe(value: boolean) {
    this.set("isSafe", Value.fromBoolean(value));
  }

  get metaData(): Bytes {
    let value = this.get("metaData");
    return value!.toBytes();
  }

  set metaData(value: Bytes) {
    this.set("metaData", Value.fromBytes(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}

export class CancelData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CancelData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type CancelData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CancelData", id.toString(), this);
    }
  }

  static load(id: string): CancelData | null {
    return changetype<CancelData | null>(store.get("CancelData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}

export class SystemCancelData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SystemCancelData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SystemCancelData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SystemCancelData", id.toString(), this);
    }
  }

  static load(id: string): SystemCancelData | null {
    return changetype<SystemCancelData | null>(
      store.get("SystemCancelData", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get errorCode(): i32 {
    let value = this.get("errorCode");
    return value!.toI32();
  }

  set errorCode(value: i32) {
    this.set("errorCode", Value.fromI32(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}

export class ChangedOwner extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ChangedOwner entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ChangedOwner must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangedOwner", id.toString(), this);
    }
  }

  static load(id: string): ChangedOwner | null {
    return changetype<ChangedOwner | null>(store.get("ChangedOwner", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldOwner(): Bytes {
    let value = this.get("oldOwner");
    return value!.toBytes();
  }

  set oldOwner(value: Bytes) {
    this.set("oldOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}

export class FeeTransferData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FeeTransferData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FeeTransferData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FeeTransferData", id.toString(), this);
    }
  }

  static load(id: string): FeeTransferData | null {
    return changetype<FeeTransferData | null>(store.get("FeeTransferData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get recipient(): Bytes {
    let value = this.get("recipient");
    return value!.toBytes();
  }

  set recipient(value: Bytes) {
    this.set("recipient", Value.fromBytes(value));
  }

  get tokens(): Array<Bytes> {
    let value = this.get("tokens");
    return value!.toBytesArray();
  }

  set tokens(value: Array<Bytes>) {
    this.set("tokens", Value.fromBytesArray(value));
  }

  get amount(): Array<BigInt> {
    let value = this.get("amount");
    return value!.toBigIntArray();
  }

  set amount(value: Array<BigInt>) {
    this.set("amount", Value.fromBigIntArray(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}

export class SystemCallData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SystemCallData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SystemCallData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SystemCallData", id.toString(), this);
    }
  }

  static load(id: string): SystemCallData | null {
    return changetype<SystemCallData | null>(store.get("SystemCallData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get actionId(): string {
    let value = this.get("actionId");
    return value!.toString();
  }

  set actionId(value: string) {
    this.set("actionId", Value.fromString(value));
  }

  get metaData(): Bytes {
    let value = this.get("metaData");
    return value!.toBytes();
  }

  set metaData(value: Bytes) {
    this.set("metaData", Value.fromBytes(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}

export class UpdateAutomationFeeData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save UpdateAutomationFeeData entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UpdateAutomationFeeData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UpdateAutomationFeeData", id.toString(), this);
    }
  }

  static load(id: string): UpdateAutomationFeeData | null {
    return changetype<UpdateAutomationFeeData | null>(
      store.get("UpdateAutomationFeeData", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldAutomationFee(): i32 {
    let value = this.get("oldAutomationFee");
    return value!.toI32();
  }

  set oldAutomationFee(value: i32) {
    this.set("oldAutomationFee", Value.fromI32(value));
  }

  get newAutomationFee(): i32 {
    let value = this.get("newAutomationFee");
    return value!.toI32();
  }

  set newAutomationFee(value: i32) {
    this.set("newAutomationFee", Value.fromI32(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}

export class UpdateBufferHfData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UpdateBufferHfData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UpdateBufferHfData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UpdateBufferHfData", id.toString(), this);
    }
  }

  static load(id: string): UpdateBufferHfData | null {
    return changetype<UpdateBufferHfData | null>(
      store.get("UpdateBufferHfData", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldBuffer(): BigInt {
    let value = this.get("oldBuffer");
    return value!.toBigInt();
  }

  set oldBuffer(value: BigInt) {
    this.set("oldBuffer", Value.fromBigInt(value));
  }

  get newBuffer(): BigInt {
    let value = this.get("newBuffer");
    return value!.toBigInt();
  }

  set newBuffer(value: BigInt) {
    this.set("newBuffer", Value.fromBigInt(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}

export class UpdateMinHfData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UpdateMinHfData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UpdateMinHfData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UpdateMinHfData", id.toString(), this);
    }
  }

  static load(id: string): UpdateMinHfData | null {
    return changetype<UpdateMinHfData | null>(store.get("UpdateMinHfData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldMinHf(): BigInt {
    let value = this.get("oldMinHf");
    return value!.toBigInt();
  }

  set oldMinHf(value: BigInt) {
    this.set("oldMinHf", Value.fromBigInt(value));
  }

  get newMinHf(): BigInt {
    let value = this.get("newMinHf");
    return value!.toBigInt();
  }

  set newMinHf(value: BigInt) {
    this.set("newMinHf", Value.fromBigInt(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}

export class Executor extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Executor entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Executor must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Executor", id.toString(), this);
    }
  }

  static load(id: string): Executor | null {
    return changetype<Executor | null>(store.get("Executor", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get executors(): Array<Bytes> {
    let value = this.get("executors");
    return value!.toBytesArray();
  }

  set executors(value: Array<Bytes>) {
    this.set("executors", Value.fromBytesArray(value));
  }
}

export class FailedExecution extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FailedExecution entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FailedExecution must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FailedExecution", id.toString(), this);
    }
  }

  static load(id: string): FailedExecution | null {
    return changetype<FailedExecution | null>(store.get("FailedExecution", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get params(): string {
    let value = this.get("params");
    return value!.toString();
  }

  set params(value: string) {
    this.set("params", Value.fromString(value));
  }

  get metadata(): Bytes {
    let value = this.get("metadata");
    return value!.toBytes();
  }

  set metadata(value: Bytes) {
    this.set("metadata", Value.fromBytes(value));
  }

  get initialHf(): BigInt {
    let value = this.get("initialHf");
    return value!.toBigInt();
  }

  set initialHf(value: BigInt) {
    this.set("initialHf", Value.fromBigInt(value));
  }

  get transactionDetail(): string {
    let value = this.get("transactionDetail");
    return value!.toString();
  }

  set transactionDetail(value: string) {
    this.set("transactionDetail", Value.fromString(value));
  }
}
