// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class ExecutionParams extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExecutionParams entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExecutionParams must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExecutionParams", id.toString(), this);
    }
  }

  static load(id: string): ExecutionParams | null {
    return changetype<ExecutionParams | null>(store.get("ExecutionParams", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get collateralToken(): Bytes {
    let value = this.get("collateralToken");
    return value!.toBytes();
  }

  set collateralToken(value: Bytes) {
    this.set("collateralToken", Value.fromBytes(value));
  }

  get debtToken(): Bytes {
    let value = this.get("debtToken");
    return value!.toBytes();
  }

  set debtToken(value: Bytes) {
    this.set("debtToken", Value.fromBytes(value));
  }

  get collateralAmount(): BigInt {
    let value = this.get("collateralAmount");
    return value!.toBigInt();
  }

  set collateralAmount(value: BigInt) {
    this.set("collateralAmount", Value.fromBigInt(value));
  }

  get debtAmount(): BigInt {
    let value = this.get("debtAmount");
    return value!.toBigInt();
  }

  set debtAmount(value: BigInt) {
    this.set("debtAmount", Value.fromBigInt(value));
  }

  get collateralAmountWithTotalFee(): BigInt {
    let value = this.get("collateralAmountWithTotalFee");
    return value!.toBigInt();
  }

  set collateralAmountWithTotalFee(value: BigInt) {
    this.set("collateralAmountWithTotalFee", Value.fromBigInt(value));
  }

  get swap(): string {
    let value = this.get("swap");
    return value!.toString();
  }

  set swap(value: string) {
    this.set("swap", Value.fromString(value));
  }

  get route(): BigInt {
    let value = this.get("route");
    return value!.toBigInt();
  }

  set route(value: BigInt) {
    this.set("route", Value.fromBigInt(value));
  }

  get rateMode(): BigInt {
    let value = this.get("rateMode");
    return value!.toBigInt();
  }

  set rateMode(value: BigInt) {
    this.set("rateMode", Value.fromBigInt(value));
  }
}

export class Swap extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Swap entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Swap must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Swap", id.toString(), this);
    }
  }

  static load(id: string): Swap | null {
    return changetype<Swap | null>(store.get("Swap", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get buyToken(): Bytes {
    let value = this.get("buyToken");
    return value!.toBytes();
  }

  set buyToken(value: Bytes) {
    this.set("buyToken", Value.fromBytes(value));
  }

  get sellToken(): Bytes {
    let value = this.get("sellToken");
    return value!.toBytes();
  }

  set sellToken(value: Bytes) {
    this.set("sellToken", Value.fromBytes(value));
  }

  get sellAmt(): BigInt {
    let value = this.get("sellAmt");
    return value!.toBigInt();
  }

  set sellAmt(value: BigInt) {
    this.set("sellAmt", Value.fromBigInt(value));
  }

  get unitAmt(): BigInt {
    let value = this.get("unitAmt");
    return value!.toBigInt();
  }

  set unitAmt(value: BigInt) {
    this.set("unitAmt", Value.fromBigInt(value));
  }

  get callData(): Bytes {
    let value = this.get("callData");
    return value!.toBytes();
  }

  set callData(value: Bytes) {
    this.set("callData", Value.fromBytes(value));
  }
}

export class Spell extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Spell entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Spell must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Spell", id.toString(), this);
    }
  }

  static load(id: string): Spell | null {
    return changetype<Spell | null>(store.get("Spell", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _targets(): Array<string> {
    let value = this.get("_targets");
    return value!.toStringArray();
  }

  set _targets(value: Array<string>) {
    this.set("_targets", Value.fromStringArray(value));
  }

  get _datas(): Array<Bytes> {
    let value = this.get("_datas");
    return value!.toBytesArray();
  }

  set _datas(value: Array<Bytes>) {
    this.set("_datas", Value.fromBytesArray(value));
  }
}

export class Account extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Account entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Account must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Account", id.toString(), this);
    }
  }

  static load(id: string): Account | null {
    return changetype<Account | null>(store.get("Account", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get submitAutomation(): Array<string> {
    let value = this.get("submitAutomation");
    return value!.toStringArray();
  }

  set submitAutomation(value: Array<string>) {
    this.set("submitAutomation", Value.fromStringArray(value));
  }

  get executeAutomation(): Array<string> {
    let value = this.get("executeAutomation");
    return value!.toStringArray();
  }

  set executeAutomation(value: Array<string>) {
    this.set("executeAutomation", Value.fromStringArray(value));
  }

  get executeMetaData(): Array<string> {
    let value = this.get("executeMetaData");
    return value!.toStringArray();
  }

  set executeMetaData(value: Array<string>) {
    this.set("executeMetaData", Value.fromStringArray(value));
  }

  get cancelData(): Array<string> {
    let value = this.get("cancelData");
    return value!.toStringArray();
  }

  set cancelData(value: Array<string>) {
    this.set("cancelData", Value.fromStringArray(value));
  }

  get systemCancelData(): Array<string> {
    let value = this.get("systemCancelData");
    return value!.toStringArray();
  }

  set systemCancelData(value: Array<string>) {
    this.set("systemCancelData", Value.fromStringArray(value));
  }
}

export class SubmitData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SubmitData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SubmitData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SubmitData", id.toString(), this);
    }
  }

  static load(id: string): SubmitData | null {
    return changetype<SubmitData | null>(store.get("SubmitData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get safeHF(): BigInt {
    let value = this.get("safeHF");
    return value!.toBigInt();
  }

  set safeHF(value: BigInt) {
    this.set("safeHF", Value.fromBigInt(value));
  }

  get thresholdHF(): BigInt {
    let value = this.get("thresholdHF");
    return value!.toBigInt();
  }

  set thresholdHF(value: BigInt) {
    this.set("thresholdHF", Value.fromBigInt(value));
  }

  get currentHf(): BigInt {
    let value = this.get("currentHf");
    return value!.toBigInt();
  }

  set currentHf(value: BigInt) {
    this.set("currentHf", Value.fromBigInt(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }
}

export class ExecuteData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExecuteData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExecuteData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExecuteData", id.toString(), this);
    }
  }

  static load(id: string): ExecuteData | null {
    return changetype<ExecuteData | null>(store.get("ExecuteData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get finalHf(): BigInt {
    let value = this.get("finalHf");
    return value!.toBigInt();
  }

  set finalHf(value: BigInt) {
    this.set("finalHf", Value.fromBigInt(value));
  }

  get initialHf(): BigInt {
    let value = this.get("initialHf");
    return value!.toBigInt();
  }

  set initialHf(value: BigInt) {
    this.set("initialHf", Value.fromBigInt(value));
  }

  get automationFee(): i32 {
    let value = this.get("automationFee");
    return value!.toI32();
  }

  set automationFee(value: i32) {
    this.set("automationFee", Value.fromI32(value));
  }

  get params(): string {
    let value = this.get("params");
    return value!.toString();
  }

  set params(value: string) {
    this.set("params", Value.fromString(value));
  }

  get spells(): string {
    let value = this.get("spells");
    return value!.toString();
  }

  set spells(value: string) {
    this.set("spells", Value.fromString(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }
}

export class ExecuteMetaData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExecuteMetaData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExecuteMetaData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExecuteMetaData", id.toString(), this);
    }
  }

  static load(id: string): ExecuteMetaData | null {
    return changetype<ExecuteMetaData | null>(store.get("ExecuteMetaData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get isSafe(): boolean {
    let value = this.get("isSafe");
    return value!.toBoolean();
  }

  set isSafe(value: boolean) {
    this.set("isSafe", Value.fromBoolean(value));
  }

  get metadata(): Bytes {
    let value = this.get("metadata");
    return value!.toBytes();
  }

  set metadata(value: Bytes) {
    this.set("metadata", Value.fromBytes(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }
}

export class CancelData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CancelData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type CancelData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CancelData", id.toString(), this);
    }
  }

  static load(id: string): CancelData | null {
    return changetype<CancelData | null>(store.get("CancelData", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }
}

export class SystemCancelData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SystemCancelData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SystemCancelData must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SystemCancelData", id.toString(), this);
    }
  }

  static load(id: string): SystemCancelData | null {
    return changetype<SystemCancelData | null>(
      store.get("SystemCancelData", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get errorCode(): i32 {
    let value = this.get("errorCode");
    return value!.toI32();
  }

  set errorCode(value: i32) {
    this.set("errorCode", Value.fromI32(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }
}

export class Executor extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Executor entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Executor must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Executor", id.toString(), this);
    }
  }

  static load(id: string): Executor | null {
    return changetype<Executor | null>(store.get("Executor", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get executors(): Array<Bytes> {
    let value = this.get("executors");
    return value!.toBytesArray();
  }

  set executors(value: Array<Bytes>) {
    this.set("executors", Value.fromBytesArray(value));
  }
}
